

### KMP运行过程



### KMP算法分析

**感谢知乎作者[HHey](https://zhuanlan.zhihu.com/p/148977262)**“KMP算法详细分析”（点击超链接即可访问原文）

#### 1、为什么取公共子串

![img](https://pic3.zhimg.com/80/v2-c8e12b52a3a8f77108faa5f39d0f3d0e_720w.jpg)

##### 排除不必要的对齐位置

> ###### 下面解释为何能够排除不必要的对齐位置

如上图所示，在右边蓝色箭头处模式串字符和文本串字符不匹配，需要更改对齐位置，以重新进行字符串匹配，在选取公共子串的过程中，保证了真后缀最左边的字符串一定是与真前缀的最左的字符串是匹配的，又由于是公共子串，那么之后的字符也会匹配，如图中红色箭头所示。假设被排除的字符串(如图中紫色线条表示的部分)中有对齐位置，那么意味着在该对齐位置能够保证后面的字符(也就是到蓝色箭头处)也能够匹配，而这就是公共子串，因此被排除的字符串对齐位置中一定是正确的，没有错误的排除掉能够匹配的位置

#### 2、为什么选最长的公共子串

![img](https://pic1.zhimg.com/80/v2-5c8a9fdf4b7340754415a3a8fb9c9f90_720w.jpg)

##### 尽可能的小的滑动，保证不会错过正确的对齐位置

> ###### 下面解释为什么选取最长公共子串不会错过正确的对齐位置

如右图所示，在绿色箭头处发生了字符不匹配，子串1表示的公共子串是e处的最长公共子串，子串2表示的是非最长公共子串，可以看到如果选择的是子串2，然后更新对齐位置，模式串和文本串就无法正确匹配了，原因在于发生了大幅度的滑动，从而把有可能对齐的位置错过了，而最长公共子串保证了每滑动一次，被排除的字符串中一定不存能够对齐的位置了

#### 3、为什么next[0] = -1

![img](https://pic1.zhimg.com/80/v2-98784cd83985d3d2cc568ab6d9f6b688_720w.jpg)

next[0] = -1;

##### 取作-1是将其作为假想的哨兵，逻辑上存在的一个通配符，可以与任何字符匹配

在模式串的第一个字符发生不匹配时，调用next数组中的值-1,和文本串中当前不匹配的字符相配，可以执行i++,j++（文本串移动一个字符，模式串为第一个字符，也就是通配符后面的字符）

可以看到，如果模式串中第一个字符不匹配，则会进入else语句，j = next[0] = -1;

下一轮的执行if语句，执行i++,j++,也就是改变对齐位置了，在if语句中0>j等同于T[i] == T[j];也就是实现了逻辑上的匹配









